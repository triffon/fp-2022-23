# Упражнение 8

## Асоциативни списъци

Асоциативните списъци (познати още като hash, map, dictionary) са списъци от наредени `(key . value)` двойки, в които на ключ съпоставяме някаква стойност.

```scheme
(define alist '((a . 10) (b . 12) (c . 18)))

;; аssoc приема стойност и асоциативен списък
;; връща първата (key . value) двойка, за която стойността е равна на key
;; ако няма такава, връща #f
(assoc 'a alist) ;; => '(a . 10)
(assoc 'd alist) ;; => #f

;; връща списък от ключовете в асоциативния списък
(define (keys alist)
  (map car alist))

;; връща списък от стойностите в асоциативния списък
(define (my-values alist)
  (map cdr alist))
```

## Графи

Можем да представим даден граф чрез **списъци на съседство** - т.е. да го разглеждаме като асоциативен списък, в който ключовете са **върховете**, а стойностите им - **съседите** на съотвения връх.

![Graph](./graph.gif)

```scheme
;; горният граф изглежда по следния начин на scheme
(define example-graph
  '((1 . (2))
    (2 . (3))
    (3 . (1 4))
    (4 . (3 5))
    (5 . (5)))

;; или по-просто
;; '((1 2) (2 3) (3 1 4) (4 3 5) (5 5))
```

---

## Задачи с асоциативни списъци

1. Дефинирайте функция `(del-assoc key alist)`, която премахва елемента с ключ `key` от асоциативния списък `alist`

    ```scheme
    > (del-assoc 2 '((1 . 2) (2 . 3) (3 . 4)))
    ;; => '((1 . 2) (3 . 4))
    ```

2. Дефинирайте функция `(add-assoc key value alist)`, която добавя елемента `(key . value)` в асоциативния списък `alist`

    ```scheme
    (define alist '((1 . 2) (2 . 3) (3 . 4)))

    > (add-assoc 4 5 alist) ;; => '((4 . 5) (1 . 2) (2 . 3) (3 . 4))
    > (add-assoc 2 5 alist) ;; => '((1 . 2) (2 . 5) (3 . 4))
    ```

3. Дефинирайте функция `(map-values func alist)`, която прилага функцията `func` над всички стойности в асоциативния списък `alist`

    ```scheme
    (define alist '((1 . 2) (2 . 3) (3 . 4)))

    > (map-values (lambda (x) (* x x)) alist)
    ;; => '((1 . 4) (2 . 9) (3 . 16))
    ```

4. Дефинирайте функция `(exists? pred? alist)`, която проверява дали съществува елемент в асоциативния списък `alist`, който да изпълнява предиката `pred?`

    ```scheme
    (define alist '((1 . 2) (2 . 3) (3 . 4)))

    > (exists? (lambda (kv) (odd? (car kv))) alist) ;; => #t
    ```

5. Дефинирайте функция `(search pred? alist)`, която връща елемента в асоциативния списък `alist`, който изпълнява предиката `pred?`

    ```scheme
    (define alist '((1 . 2) (2 . 3) (3 . 4)))

    > (search (lambda (kv) (odd? (car kv))) alist) ;; => '(1 . 2)
    > (search (lambda (kv) (> (car kv) 5))  alist) ;; => #f
    ```
  
6. Дефинирайте функция `(histogram lst)`, която връща хистограма на срещанията на всички елементи в `lst` под формата на асоциативен списък

    ```scheme
    > (histogram '(8 7 1 7 8 2 2 8 2 7 8 1))
    ;; => '((8 . 4) (7 . 3) (1 . 2) (2 . 3))
    ;; 8 се среща 4 пъти, 7 се среща 3 пъти, etc.
    ```

## Задачи с графи

```scheme
(define graph
   '((1 2)
     (2 1 3 4)
     (3 3)
     (4 1 3)
     (5 6)
     (6)))
```

7. Дефинирайте функция `(vertices graph)`, която връща списък от върховете в подадения граф

    ```scheme
    > (vertices graph) ;; => '(1 2 3 4 5 6)
    ```

8. Дефинирайте функция `(children vertex graph)`, която връща списък от децата на върха `vertex` в подадения граф

    ```scheme
    > (children 4 graph) ;; => '(1 3)
    ```

9. Дефинирайте функция `(edge? u v graph)`, която проверява дали има ребро от върха `u` до върха `v` в подадения граф

    ```scheme
    > (edge? 2 3 graph) ;; => #t
    > (edge? 3 2 graph) ;; => #f
    ```

10. Дефинирайте функция `(search-child vertex pred? graph)`, която проверява дали съществува дете на върха `vertex` в подадения граф, което удовлетворява предиката `pred?`

    ```scheme
    > (search-child 4 odd?  graph) ;; => 1
    > (search-child 4 even? graph) ;; => #f
    ```

    Алтернативно, дефинирайте функция `(filter-children vertex pred? graph)`, която връща списък от всички деца на върха `vertex`, които удовлетворяват предиката `pred?`

    ```scheme
    > (filter-children 4 odd?  graph) ;; => '(1 3)
    > (filter-children 4 even? graph) ;; => '()
    ```

11. Дефинирайте функция `(parents vertex graph)`, която намира родителите на връхa `vertex` в подадения граф

    ```scheme
    > (parents 3 graph) ;; => '(2 3 4)
    > (parents 5 graph) ;; => '()
    ```

12. Дефинирайте функция `(to-edges graph)`, която връща списък от всички ребра в подадения граф

    ```scheme
    > (to-edges graph)
    ;; => '((1 . 2) (2 . 1) (2 . 3) (2 . 4)
    ;;      (3 . 3) (4 . 1) (4 . 3) (5 . 6))
    ```

13. Дефинирайте функция `(from-edges edges)`, която конструира граф (представен чрез списъци на съседство) от подадения списък от ребра

14. Дефинирайте функция `(invert graph)`, която връща нова граф, получен от подадения като "обърнем" всички ребра в него

    ```scheme
    > (invert graph)
    ;; => '((1 2 4)
    ;;      (2 1)
    ;;      (3 2 3 4)
    ;;      (4 2)
    ;;      (5)
    ;;      (6 5)))
    ```

15. Дефинирайте функция `(contains-path? graph path)`, която проверява дали пътят `path` се съдържа в подадения граф

    ```scheme
    > (contains-path? graph '(2 4 1 2 3)) ;; => #t
    > (contains-path? graph '(2 4 5 2 3)) ;; => #f
    ```

16. Дефинирайте функция `(extend-path graph path)`, която връща всички възможни "разширения" на пътя `path` в подадения граф (търсим прости пътища, т.е. без повторения на върхове)
Упътване: Дефинирайте функция `(extend-once graph path)`, която "разширява" подадения път само веднъж

    ```scheme
    > (extend-path graph '(1 2))
    ;; => '((1 2) (1 2 3) (1 2 4) (1 2 4 3))
    ```

17. Дефинирайте функция `(shortest-path u v graph)`, която намира най-късия път от върха `u` до върха `v` в подадения граф.
Упътване: `(shortest-path u v graph)`, където `graph` е граф без тегла на ребрата = `(bfs u)`

    ```scheme
    > (shortest-path 1 3 graph) ;; => '(1 2 3)
    ```

18. Дефинирайте функция `(symmetric? graph)`, която проверява дали дадения граф е симетричен (ако съществува ребро от връх `u` до `v`, то същвстува и ребро от `v` до `u`) 

    ```scheme
    (define symmetric-graph
      '((1 2 4)
        (2 1 3 4)
        (3 2 3 4)
        (4 1 2 3)
        (5 6)
        (6 5)))

    > (symmetric? graph)            ;; => #f
    > (symmetric? symmetric-graph)  ;; => #t
    ```

19. Дефинирайте функция `(one-child-policy? graph)`, която проверява дали в дадения граф е изпълнено следното условие: "даден възел може да има повече от един наследник само ако е той е единствен наследник на родителя си"

    ```scheme
    (define compliant-graph
      '((1 3)
        (2 3)
        (3 4 5)
        (4 6)
        (5 7)
        (8)))

    (define non-compliant-graph
      '((1 3)
        (2 3)
        (3 4 5)
        (4 6)
        (5 7 8)
        (8)))

    > (one-child-policy? compliant-graph)     ;; => #t
    > (one-child-policy? non-compliant-graph) ;; => #f
    ```