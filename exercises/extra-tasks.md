# Бонус задачи за списъци "за любознателните"

### Зад.1
Да се напише функция `subsets`, която генерира списъка от всички подмножества на елементите на даден списък. Редът на подмножествата в резултата е без значение:
```
(subsets '(1 2 3)) -> '(() (1) (2) (3) (1 2) (1 3) (2 3) (1 2 3))
```
_Бонус:_ подмножествата да се генерират в лексикографска наредба (както в горния пример)

### Зад.2
Да се напише функция `permutations`, която генерира списъка от всички пермутации на даден списък. Редът на пермутациите в резултата е без значение:
```
(permutations '(1 2 3)) -> '((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))
```
_Бонус:_ пермутациите да се генерират в лексикографска наредба (както в горния пример)

### Зад.3
Да се напише функция `nextPerm` или `prevPerm`, която по даден списък да връща лексикографски* следващата/предишната негова пермутация. Ако такава няма (текущата е последната/първата в наредбата), функцията трябва да върне `#f` в Scheme и `Nothing` в Haskell:
```
(nextPerm '(2 1 3)) -> '(2 3 1)
(nextPerm '(3 2 1)) -> #f
```
\* Заради асиметричната структура на списъците може да се окаже, че е по-удобно да се генерират в *колексикографска* наредба (четена от дясно наляво) - оставяме на Вас да експериментирате кое представяне води до по-лесна имплементация :) Целта е да можем да "итерираме" удобно всички пермутации, т.е. ...

### Зад.4
... да се използват функциите от горната задача за генериране на списъка от всички пермутации на даден списък (в какъвто ред се генерират оттам)

### Зад.5
Да се напише функция `longestIncr`, която връща максимално дълга нарастваща подредица от елементите на даден списък. Тази подредица не е задължително да включва последователни елементи на списъка, или да е уникална, но е важно да запазва оригиналната наредба на елементите:
```
(longestIncr '(2 0 1 3 8 4 5 9 6 5 8)) -> '(0 1 3 4 5 6 8)
участващи ел-ти: ^ ^ ^   ^ ^   ^   ^
```

### Зад.6
Да се дефинират безкрайните потоци `fibs` от числата на Фибоначи и `triangs` от всички триъгълни числа. Задължително е самият поток да използва себе си рекурсивно, и при нужда други подобно дефинирани потоци, например:
```
(define ones (cons-stream 1 ones))
(define nats (cons-stream 1 (add-streams ones nats)))
```
