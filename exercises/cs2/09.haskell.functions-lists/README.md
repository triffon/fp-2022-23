# 09. Функции, кортежи, списъци

[Подробно разписаното упражнение 09 на inf2 за въведение в Хаскел](https://github.com/triffon/fp-2022-23/blob/main/exercises/inf2/09/README.md#haskell)

## Функции и кортежи

1. Да се напише функцията cylinderVolume, която изчислява обема на даден цилиндър по неговия радиус и височина. Също и функция pyramidVolume
   ```hs
   cylinderVolume 2 5 -> 62.83185307179586
   ```

1. `gcd a b` - най-голям общ делител на а и b. Винаги е положително число, защото 1 е делител на всички числа.

1. `countDigits n` - брой на цифрите на число

1. `isAutomorphic n` - дали n на втора степен завършва с n

1. `fastpow x n` - степенуване с логаритмична сложност

1. Да се напишат функции `complAdd`, `complSub` и `complMul`, които извършват
   съответните операции над комплексни числа, представени като наредени двойки от
   координатите си:

   ```hs
   complAdd (1,2) (-3,5) -> (-2,7)
   complSub (4,8) (2,-1) -> (2,9)
   complMul (3,5) (2,1) -> (1,13)
   ```

## Списъци
За да имплементирате някои функции от Prelude, избягвайки грешките за двусмислици, може да скриете вградените дефиниции по следния начин:
```hs
import Prelude hiding (sum, length, maximum, elem, reverse, take, drop, concat, zipWith)
```
Може да избегнете двусмислицата и като използвате уникално име - конвенцията е добавяне на `'` накрая на името на функцията, например `take'`.


### Функции над списъци от модула [Prelude](https://hackage.haskell.org/package/base-4.16.0.0/docs/Prelude.html#g:13)
Може да се ползват наготово в бъдеще, но днес имплементираме някои от тях.

<details>
  <summary>Покажи</summary>

```hs
(++) :: [a] -> [a] -> [a] -- infixr 5
map :: (a -> b) -> [a] -> [b]
filter :: (a -> Bool) -> [a] -> [a]

head :: [a] -> a
tail :: [a] -> [a]

init :: [a] -> [a]
last :: [a] -> a

(!!) :: [a] -> Int -> a -- infixl 9
null :: [a] -> Bool

length :: [a] -> Int
elem :: Eq a => a -> [a] -> Bool
notElem :: Eq a => a -> [a] -> Bool
reverse :: [a] -> [a]
sum :: Num a => [a] -> a
product :: Num a => [a] -> a
maximum :: Ord a => [a] -> a
minimum :: Ord a => [a] -> a

and :: [Bool] -> Bool
or :: [Bool] -> Bool
any :: (a -> Bool) -> [a] -> Bool
all :: (a -> Bool) -> [a] -> Bool
concat :: [[a]] -> [a]
concatMap :: (a -> [b]) -> [a] -> [b]

iterate :: (a -> a) -> a -> [a]
repeat :: a -> [a]
replicate :: Int -> a -> [a]
cycle :: [a] -> [a]

take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
takeWhile :: (a -> Bool) -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]

span :: (a -> Bool) -> [a] -> ([a], [a])
break :: (a -> Bool) -> [a] -> ([a], [a])
splitAt :: Int -> [a] -> ([a], [a])

lookup :: Eq a => a -> [(a, b)] -> Maybe b

zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

lines :: String -> [String]
words :: String -> [String]
unlines :: [String] -> String
unwords :: [String] -> String
```

#### От по-висок ред:
```hs
foldr :: (a -> b -> b) -> b -> [a] -> b
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl' :: (b -> a -> b) -> b -> [a] -> b
foldr1 :: (a -> a -> a) -> [a] -> a
foldl1 :: (a -> a -> a) -> [a] -> a

scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
scanl1 :: (a -> a -> a) -> [a] -> [a]
```
</details>

#### Още полезни функции могат да се намерят и в модула [Data.List](https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-List.html#v:intersperse)
Тези не са наготово - за да се ползват на контролно/изпит трябва да се имплементират. Все пак е добър списък от полезни функции за работа със списъци и не е лоша идея да си ги имплементирате сега за упражнение.
<details>
  <summary>Покажи</summary>

  ```haskell
  intersperse :: a -> [a] -> [a]
  intercalate :: [a] -> [[a]] -> [a]
  transpose :: [[a]] -> [[a]]
  subsequences :: [a] -> [[a]]
  permutations :: [a] -> [[a]]

  stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
  group :: Eq a => [a] -> [[a]]
  inits :: [a] -> [[a]]
  tails :: [a] -> [[a]]

  isPrefixOf :: Eq a => [a] -> [a] -> Bool
  isSuffixOf :: Eq a => [a] -> [a] -> Bool
  isInfixOf :: Eq a => [a] -> [a] -> Bool
  isSubsequenceOf :: Eq a => [a] -> [a] -> Bool

  partition :: (a -> Bool) -> [a] -> ([a], [a])
  elemIndex :: Eq a => a -> [a] -> Maybe Int
  elemIndices :: Eq a => a -> [a] -> [Int]
  findIndex :: (a -> Bool) -> [a] -> Maybe Int
  findIndices :: (a -> Bool) -> [a] -> [Int]

  nub :: Eq a => [a] -> [a]
  delete :: Eq a => a -> [a] -> [a]
  (\\) :: Eq a => [a] -> [a] -> [a] infix 5
  union :: Eq a => [a] -> [a] -> [a]
  intersect :: Eq a => [a] -> [a] -> [a]

  sortOn :: Ord b => (a -> b) -> [a] -> [a]

  nubBy :: (a -> a -> Bool) -> [a] -> [a]
  deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
  deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
  unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
  intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
  groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
  sortBy :: (a -> a -> Ordering) -> [a] -> [a]

  maximumBy :: (a -> a -> Ordering) -> [a] -> a
  minimumBy :: (a -> a -> Ordering) -> [a] -> a
  ```
</details>

### Задачи за списъци:

Напишете типови декларации и дефиниции на следните функции:
1. `isSorted xs` - проверява дали списък от числа е сортиран
1. `insertionSort xs` - сортира списък по алгоритъма insertion sort
4. `maximum' xs` - намира най-големия елемент в списък
5. `elem' x ys` - намира дали елемент се съдържа в списък
   ```hs
   elem' :: a -> [a] -> Bool
   ```
6. `reverse' xs` – обръща реда на елементите на списък
7. `isPrefix xs ys` – приема два списъка и връща дали първия е префикс на втория
   ```hs
   isPrefix [1,2,3] [1,2,3,4,5] -> True
   ```
8. `take' n xs` - взима първите `n` елемента от даден списък
9. `drop' n xs` - премахва първите `n` елемента от даден списък
1. `chunk n xs` - разделя списъка `xs` на списъци с дължина `n`:
   ```haskell
   chunk 3 [1..10] -> [[1,2,3], [4,5,6], [7,8,9], [10]]
   ```
8. `takeWhile' p xs` - взима елементи `x` от `xs` докато е вярно че `p x`
   ```haskell
   takeWhile' :: (a -> Bool) -> [a] -> [a]
   ```
9. `dropWhile' p xs` - премахва елементи `x` от `xs` докато е вярно че `p x`
10. `zip'` - по дадени два списъка връща списък от наредени двойки с елементите им
    ```hs
    zip' [1,2,3] [4,5,6,7] -> [(1,4),(2,5),(3,6)]
    ```
11. `concat'` - от списък от списъци намяла с 1 нивото на влагане, слепяйки всички елементи на входния списък
    ```hs
    concat' [[1,2,3],[4],[5,6]] -> [1,2,3,4,5,6]
    ```
12. `zipWith'` - по два списъка образува нов, извиквайки функция над всяка съответна двойка елементи
    ```hs
    zipWith' (,) [1,2,3] [4,5,6,7] -> [(1,4),(2,5),(3,6)]
    zipWith' (+) [1,2,3] [4,5,6,7] -> [5,7,9]
    ```
1. `unzip xs` - по списък от наредени двойки връща наредена двойка от списъци

1. `uninterleave xs` -- по списък xs, връща наредена двойка (ys,zs), където
   - ys са елементите на нечетни позиции в xs
   - zs са елементите на четни позиции в xs
   Може да използвате foldl/foldr

1. Покупка се означава с наредена тройка от име на магазин (низ), категория (низ) и цена (дробно число).

   Да се реализира функция, която по даден списък от покупки връща списък от тройки, съдържащи категория, обща цена на покупките в тази категория и името на магазина, в който общата цена на покупките в тази категория е максимална. Всяка категория да се среща в точно една тройка от резултата.

   Да се реализира функция, която по даден списък от покупки връща списък от тройки, съдържащи име на магазин, обща цена на покупките в този магазин и името на категорията, в която е направена покупка за цена максимално близка до средното аритметично на цените на покупките в този магазин. Всеки магазин да се среща в точно една тройка от резултата.

   Да се реализира функция, която по даден списък от покупки връща списък от тройки, съдържащи име на магазин, име на категория и средна цена на покупките в този магазин и тази категория. Всяка двойка от магазин и категория, за които има поне една покупка, да се среща в точно една тройка от резултата.
